/*
 * This file is part of Dependency-Track.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * Copyright (c) OWASP Foundation. All Rights Reserved.
 */
package org.dependencytrack.event.kafka.processor;

import org.dependencytrack.event.kafka.KafkaTopics;
import org.dependencytrack.model.Project;
import org.dependencytrack.model.VulnerabilityScan;
import org.dependencytrack.proto.notification.v1.Notification;
import org.dependencytrack.proto.notification.v1.ProjectVulnAnalysisCompleteSubject;
import org.dependencytrack.proto.vulnanalysis.v1.ScanResult;
import org.junit.Test;

import java.util.Date;
import java.util.List;
import java.util.UUID;

import static org.assertj.core.api.Assertions.assertThat;
import static org.dependencytrack.proto.notification.v1.Group.GROUP_PROJECT_VULN_ANALYSIS_COMPLETE;
import static org.dependencytrack.proto.notification.v1.Level.LEVEL_INFORMATIONAL;
import static org.dependencytrack.proto.notification.v1.Scope.SCOPE_PORTFOLIO;
import static org.dependencytrack.util.KafkaTestUtil.deserializeKey;
import static org.dependencytrack.util.KafkaTestUtil.deserializeValue;

public class ProcessedVulnerabilityScanResultProcessorTest extends AbstractProcessorTest {

    @Test
    public void testProcessWithResultWithoutScannerResults() throws Exception {
        final var project = new Project();
        project.setName("acme-app");
        qm.persist(project);

        final var vulnScan = new VulnerabilityScan();
        vulnScan.setToken(UUID.randomUUID().toString());
        vulnScan.setTargetType(VulnerabilityScan.TargetType.PROJECT);
        vulnScan.setTargetIdentifier(project.getUuid());
        vulnScan.setStatus(VulnerabilityScan.Status.IN_PROGRESS);
        vulnScan.setExpectedResults(1);
        vulnScan.setStartedAt(new Date());
        vulnScan.setUpdatedAt(vulnScan.getStartedAt());
        qm.persist(vulnScan);

        // Create a ScanResult without any ScannerResults attached to it.
        // This might happen when no scanner is capable of scanning a component,
        // or when all scanners are disabled.
        final var scanResult = ScanResult.newBuilder().build();

        final var processor = new ProcessedVulnerabilityScanResultProcessor();
        processor.process(List.of(aConsumerRecord(vulnScan.getToken(), scanResult).build()));

        qm.getPersistenceManager().refresh(vulnScan);
        assertThat(vulnScan.getStatus()).isEqualTo(VulnerabilityScan.Status.COMPLETED);

        assertThat(kafkaMockProducer.history()).satisfiesExactly(record -> {
            assertThat(record.topic()).isEqualTo(KafkaTopics.NOTIFICATION_PROJECT_VULN_ANALYSIS_COMPLETE.name());

            final String recordKey = deserializeKey(KafkaTopics.NOTIFICATION_PROJECT_VULN_ANALYSIS_COMPLETE, record);
            assertThat(recordKey).isEqualTo(project.getUuid().toString());

            final Notification notification = deserializeValue(KafkaTopics.NOTIFICATION_PROJECT_VULN_ANALYSIS_COMPLETE, record);
            assertThat(notification.getScope()).isEqualTo(SCOPE_PORTFOLIO);
            assertThat(notification.getGroup()).isEqualTo(GROUP_PROJECT_VULN_ANALYSIS_COMPLETE);
            assertThat(notification.getLevel()).isEqualTo(LEVEL_INFORMATIONAL);
            assertThat(notification.getSubject().is(ProjectVulnAnalysisCompleteSubject.class)).isTrue();

            final var subject = notification.getSubject().unpack(ProjectVulnAnalysisCompleteSubject.class);
            assertThat(subject.getProject().getUuid()).isEqualTo(project.getUuid().toString());
            assertThat(subject.getFindingsCount()).isZero();
        });
    }

}