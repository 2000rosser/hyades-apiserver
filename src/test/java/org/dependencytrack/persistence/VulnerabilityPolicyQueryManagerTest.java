package org.dependencytrack.persistence;

import alpine.persistence.PaginatedResult;
import org.dependencytrack.AbstractPostgresEnabledTest;
import org.dependencytrack.model.AnalysisJustification;
import org.dependencytrack.model.AnalysisState;
import org.dependencytrack.model.VulnerabilityPolicy;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicyAnalysis;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicyRating;
import org.junit.Test;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.Assert.assertNotNull;

public class VulnerabilityPolicyQueryManagerTest extends AbstractPostgresEnabledTest {
    private static VulnerabilityPolicy getVulnerabilityPolicyInstance() throws ParseException {
        SimpleDateFormat formatter = new SimpleDateFormat("dd-MMM-yyyy");
        String validFromInString = "7-Jun-2020";
        Date validFrom = formatter.parse(validFromInString);

        String validUntilInString = "7-Jun-2023";
        Date validUntil = formatter.parse(validUntilInString);

        VulnerabilityPolicy vulnPolicy = new VulnerabilityPolicy();
        vulnPolicy.setCreated(new Date());
        vulnPolicy.setConditions(new String[]{"vuln.id == \"CVE-123\" || vuln.aliases.exists(alias, alias.id == \"CVE-123\")",
                "component.name == \"foo\" && project.name == \"bar\" && \"internal\" in project.tags && !component.is_dependency_of(v1.Component{group: \"org.springframework.boot\"}"});
        vulnPolicy.setName("name");
        vulnPolicy.setValidFrom(validFrom);
        vulnPolicy.setValidUntil(validUntil);
        VulnerabilityPolicyAnalysis vulnerabilityPolicyAnalysis = new VulnerabilityPolicyAnalysis();
        vulnerabilityPolicyAnalysis.setState(VulnerabilityPolicyAnalysis.State.NOT_AFFECTED);
        vulnerabilityPolicyAnalysis.setJustification(VulnerabilityPolicyAnalysis.Justification.CODE_NOT_REACHABLE);
        vulnerabilityPolicyAnalysis.setDetails("something");
        vulnerabilityPolicyAnalysis.setSuppress(true);
        vulnPolicy.setAnalysis(vulnerabilityPolicyAnalysis);
        VulnerabilityPolicyRating rating = new VulnerabilityPolicyRating();
        rating.setSeverity(VulnerabilityPolicyRating.Severity.HIGH);
        rating.setMethod(VulnerabilityPolicyRating.Method.CVSSV3);
        rating.setScore(6.3);
        rating.setVector("CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L");
        vulnPolicy.setRatings(List.of(rating));
        return vulnPolicy;
    }

    @Test
    public void testVulnerabilityPolicyIsCreated() throws Exception {

        VulnerabilityPolicy vulnPolicy = getVulnerabilityPolicyInstance();

        int count = qm.createVulnerabilityPolicy(vulnPolicy, null);

        assertThat(count).isEqualTo(1);
        List<VulnerabilityPolicy> vulnerabilityPolicies = qm.getAllVulnerabilityPolicies();
        assertNotNull(vulnerabilityPolicies);
        assertThat(vulnerabilityPolicies).hasSize(1);
        assertThat(vulnerabilityPolicies).satisfiesExactlyInAnyOrder(
                vulnerabilityPolicy -> {
                    assertThat(vulnerabilityPolicy).isNotNull();
                    assertThat(vulnerabilityPolicy.getCreated()).isNotNull();
                    assertThat(vulnerabilityPolicy.getConditions()).isEqualTo(vulnPolicy.getConditions());
                    assertThat(vulnerabilityPolicy.getAnalysis()).isNotNull();
                    assertThat(vulnerabilityPolicy.getAnalysis().getState().name()).isEqualTo(AnalysisState.NOT_AFFECTED.name());
                    assertThat(vulnerabilityPolicy.getAnalysis().isSuppress()).isTrue();
                    assertThat(vulnerabilityPolicy.getAnalysis().getJustification().name()).isEqualTo(AnalysisJustification.CODE_NOT_REACHABLE.name());
                    assertThat(vulnerabilityPolicy.getAnalysis().getDetails()).isEqualTo("something");
                    assertThat(vulnerabilityPolicy.getRatings()).isNotNull();
                    assertThat(vulnerabilityPolicy.getRatings()).hasSize(1);
                    assertThat(vulnerabilityPolicy.getRatings()).satisfiesExactlyInAnyOrder(
                            rating1 -> {
                                assertThat(rating1.getScore()).isEqualTo(6.3);
                                assertThat(rating1.getMethod()).isEqualTo(VulnerabilityPolicyRating.Method.CVSSV3);
                                assertThat(rating1.getSeverity()).isEqualTo(VulnerabilityPolicyRating.Severity.HIGH);
                                assertThat(rating1.getVector()).isEqualTo("CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L");
                            });
                });
    }

    @Test
    public void testVulnerabilityPolicyIsCreatedWithoutRating() throws Exception {

        VulnerabilityPolicy vulnPolicy = getVulnerabilityPolicyInstance();
        vulnPolicy.setRatings(null);

        int count = qm.createVulnerabilityPolicy(vulnPolicy, null);

        assertThat(count).isEqualTo(1);
        List<VulnerabilityPolicy> vulnerabilityPolicies = qm.getAllVulnerabilityPolicies();
        assertNotNull(vulnerabilityPolicies);
        assertThat(vulnerabilityPolicies).hasSize(1);
        assertThat(vulnerabilityPolicies).satisfiesExactlyInAnyOrder(
                vulnerabilityPolicy -> {
                    assertThat(vulnerabilityPolicy).isNotNull();
                    assertThat(vulnerabilityPolicy.getCreated()).isNotNull();
                    assertThat(vulnerabilityPolicy.getConditions()).isEqualTo(vulnPolicy.getConditions());
                    assertThat(vulnerabilityPolicy.getAnalysis()).isNotNull();
                    assertThat(vulnerabilityPolicy.getAnalysis().getState().name()).isEqualTo(AnalysisState.NOT_AFFECTED.name());
                    assertThat(vulnerabilityPolicy.getAnalysis().isSuppress()).isTrue();
                    assertThat(vulnerabilityPolicy.getAnalysis().getJustification().name()).isEqualTo(AnalysisJustification.CODE_NOT_REACHABLE.name());
                    assertThat(vulnerabilityPolicy.getAnalysis().getDetails()).isEqualTo("something");
                    assertThat(vulnerabilityPolicy.getRatings()).isNull();
                });
    }

    @Test
    public void testVulnerabilityPolicyIsDeleted() throws Exception{
        VulnerabilityPolicy vulnPolicy = getVulnerabilityPolicyInstance();
        int count = qm.createVulnerabilityPolicy(vulnPolicy, null);
        assertThat(count).isEqualTo(1);
        qm.deleteVulnerabilityPolicyByName(vulnPolicy.getName(), null);
        List<VulnerabilityPolicy> policies = qm.getAllVulnerabilityPolicies();
        assertThat(policies).isEmpty();
    }

    @Test
    public void testVulnerabilityPolicyIsUpdated() throws Exception {

        VulnerabilityPolicy vulnPolicy = getVulnerabilityPolicyInstance();

        int count = qm.createVulnerabilityPolicy(vulnPolicy, null);
        assertThat(count).isEqualTo(1);

        String[] updatedConditions = new String[]{"foo=something", "bar=baz", "c=woah"};
        vulnPolicy.setConditions(updatedConditions);
        qm.updateVulnerablePolicyByName(vulnPolicy, null);

        VulnerabilityPolicy vulnerabilityPolicy = qm.getVulnerabilityPolicyByName(vulnPolicy.getName());
        assertNotNull(vulnerabilityPolicy);
        assertThat(vulnerabilityPolicy.getCreated()).isNotNull();
        assertThat(vulnerabilityPolicy.getConditions()).isEqualTo(updatedConditions);
        assertThat(vulnerabilityPolicy.getAnalysis()).isNotNull();
        assertThat(vulnerabilityPolicy.getAnalysis().getState().name()).isEqualTo(AnalysisState.NOT_AFFECTED.name());
        assertThat(vulnerabilityPolicy.getAnalysis().isSuppress()).isTrue();
        assertThat(vulnerabilityPolicy.getAnalysis().getJustification().name()).isEqualTo(AnalysisJustification.CODE_NOT_REACHABLE.name());
        assertThat(vulnerabilityPolicy.getAnalysis().getDetails()).isEqualTo("something");
        assertThat(vulnerabilityPolicy.getRatings()).isNotNull();
        assertThat(vulnerabilityPolicy.getRatings()).hasSize(1);
        assertThat(vulnerabilityPolicy.getRatings()).satisfiesExactlyInAnyOrder(
                rating1 -> {
                    assertThat(rating1.getScore()).isEqualTo(6.3);
                    assertThat(rating1.getMethod()).isEqualTo(VulnerabilityPolicyRating.Method.CVSSV3);
                    assertThat(rating1.getSeverity()).isEqualTo(VulnerabilityPolicyRating.Severity.HIGH);
                    assertThat(rating1.getVector()).isEqualTo("CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L");
                });

    }

    @Test
    public void testVulnerabilitiesFetchedWithNoFilter() throws Exception {
        VulnerabilityPolicy vulnPolicy = getVulnerabilityPolicyInstance();

        int count = qm.createVulnerabilityPolicy(vulnPolicy, null);

        assertThat(count).isEqualTo(1);
        PaginatedResult result = qm.getAllVulnerabilityPolicies(null, null, null);
        assertNotNull(result);
        assertThat(result.getObjects()).hasSize(1);
    }

    @Test
    public void testVulnerabilitiesFetchedWithNameFilter() throws Exception {
        VulnerabilityPolicy vulnPolicy = getVulnerabilityPolicyInstance();

        int count = qm.createVulnerabilityPolicy(vulnPolicy, null);

        assertThat(count).isEqualTo(1);
        PaginatedResult result = qm.getAllVulnerabilityPolicies("name", null, null);
        assertNotNull(result);
        assertThat(result.getObjects()).hasSize(1);
    }

    @Test
    public void testNoVulnerabilitiesFetchedWithNameNotMatching() throws Exception {
        VulnerabilityPolicy vulnPolicy = getVulnerabilityPolicyInstance();

        int count = qm.createVulnerabilityPolicy(vulnPolicy, null);

        assertThat(count).isEqualTo(1);
        PaginatedResult result = qm.getAllVulnerabilityPolicies("othername", null, null);
        assertNotNull(result);
        assertThat(result.getObjects()).hasSize(0);
    }

    @Test
    public void testVulnerabilitiesFetchedWithDateFilter() throws Exception {
        VulnerabilityPolicy vulnPolicy = getVulnerabilityPolicyInstance();

        int count = qm.createVulnerabilityPolicy(vulnPolicy, null);

        assertThat(count).isEqualTo(1);
        SimpleDateFormat formatter = new SimpleDateFormat("dd-MMM-yyyy");
        String validFromInString = "5-Jun-2020";
        Date validFrom = formatter.parse(validFromInString);
        PaginatedResult result = qm.getAllVulnerabilityPolicies(null, validFrom, null);
        assertNotNull(result);
        assertThat(result.getObjects()).hasSize(1);
    }

    @Test
    public void testNoVulnerabilitiesFetchedWithNameAndDateFilterNotMatching() throws Exception{
        VulnerabilityPolicy vulnPolicy = getVulnerabilityPolicyInstance();

        int count = qm.createVulnerabilityPolicy(vulnPolicy, null);

        assertThat(count).isEqualTo(1);

        PaginatedResult result = qm.getAllVulnerabilityPolicies("name", new Date(), null);
        assertNotNull(result);
        assertThat(result.getObjects()).hasSize(0);
    }

    @Test
    public void testVulnerabilitiesFetchedWithNameAndDateUntilFilter() throws Exception {
        VulnerabilityPolicy vulnPolicy = getVulnerabilityPolicyInstance();

        int count = qm.createVulnerabilityPolicy(vulnPolicy, null);

        assertThat(count).isEqualTo(1);
        SimpleDateFormat formatter = new SimpleDateFormat("dd-MMM-yyyy");
        String validUntilInString = "9-Jun-2023";
        Date validUntil = formatter.parse(validUntilInString);
        PaginatedResult result = qm.getAllVulnerabilityPolicies("name", null, validUntil);
        assertNotNull(result);
        assertThat(result.getObjects()).hasSize(1);
    }
}
