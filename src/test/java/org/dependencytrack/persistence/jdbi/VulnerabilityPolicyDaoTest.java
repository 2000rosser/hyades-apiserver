package org.dependencytrack.persistence.jdbi;

import org.dependencytrack.AbstractPostgresEnabledTest;
import org.dependencytrack.model.AnalysisJustification;
import org.dependencytrack.model.AnalysisState;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicy;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicyAnalysis;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicyRating;
import org.junit.Test;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.ZoneOffset;
import java.time.ZonedDateTime;
import java.util.Date;
import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.Assert.assertNotNull;

public class VulnerabilityPolicyDaoTest extends AbstractPostgresEnabledTest {
    private static VulnerabilityPolicy getVulnerabilityPolicyInstance() throws ParseException {
        SimpleDateFormat formatter = new SimpleDateFormat("dd-MMM-yyyy");
        String validFromInString = "7-Jun-2020";
        Date validFrom = formatter.parse(validFromInString);

        String validUntilInString = "7-Jun-2023";
        Date validUntil = formatter.parse(validUntilInString);

        VulnerabilityPolicy vulnPolicy = new VulnerabilityPolicy();
        vulnPolicy.setCreated(ZonedDateTime.now(ZoneOffset.UTC));
        vulnPolicy.setConditions(List.of("vuln.id == \"CVE-123\" || vuln.aliases.exists(alias, alias.id == \"CVE-123\")",
                "component.name == \"foo\" && project.name == \"bar\" && \"internal\" in project.tags && !component.is_dependency_of(v1.Component{group: \"org.springframework.boot\"}"));
        vulnPolicy.setName("name");
        vulnPolicy.setValidFrom(ZonedDateTime.ofInstant(validFrom.toInstant(), ZoneOffset.UTC));
        vulnPolicy.setValidUntil(ZonedDateTime.ofInstant(validUntil.toInstant(), ZoneOffset.UTC));
        vulnPolicy.setUpdated(ZonedDateTime.now(ZoneOffset.UTC));
        VulnerabilityPolicyAnalysis vulnerabilityPolicyAnalysis = new VulnerabilityPolicyAnalysis();
        vulnerabilityPolicyAnalysis.setState(VulnerabilityPolicyAnalysis.State.NOT_AFFECTED);
        vulnerabilityPolicyAnalysis.setJustification(VulnerabilityPolicyAnalysis.Justification.CODE_NOT_REACHABLE);
        vulnerabilityPolicyAnalysis.setDetails("something");
        vulnerabilityPolicyAnalysis.setSuppress(true);
        vulnPolicy.setAnalysis(vulnerabilityPolicyAnalysis);
        VulnerabilityPolicyRating rating = new VulnerabilityPolicyRating();
        rating.setSeverity(VulnerabilityPolicyRating.Severity.HIGH);
        rating.setMethod(VulnerabilityPolicyRating.Method.CVSSV3);
        rating.setScore(6.3);
        rating.setVector("CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L");
        vulnPolicy.setRatings(List.of(rating));
        return vulnPolicy;
    }

    @Test
    public void testVulnerabilityPolicyIsCreated() throws Exception {

        VulnerabilityPolicy vulnPolicy = getVulnerabilityPolicyInstance();

        final int count = JdbiFactory.jdbi(qm).withExtension(VulnerabilityPolicyDao.class,
                dao -> dao.createVulnerabilityPolicy(vulnPolicy));

        assertThat(count).isEqualTo(1);

        List<VulnerabilityPolicy> vulnerabilityPolicies = JdbiFactory.jdbi(qm).withExtension(VulnerabilityPolicyDao.class,
                dao -> dao.getAllVulnerabilityPolicies());

        assertNotNull(vulnerabilityPolicies);
        assertThat(vulnerabilityPolicies).hasSize(1);
        assertThat(vulnerabilityPolicies).satisfiesExactlyInAnyOrder(
                vulnerabilityPolicy -> {
                    assertThat(vulnerabilityPolicy).isNotNull();
                    assertThat(vulnerabilityPolicy.getCreated()).isNotNull();
                    assertThat(vulnerabilityPolicy.getConditions()).isEqualTo(vulnPolicy.getConditions());
                    assertThat(vulnerabilityPolicy.getAnalysis()).isNotNull();
                    assertThat(vulnerabilityPolicy.getAnalysis().getState().name()).isEqualTo(AnalysisState.NOT_AFFECTED.name());
                    assertThat(vulnerabilityPolicy.getAnalysis().isSuppress()).isTrue();
                    assertThat(vulnerabilityPolicy.getAnalysis().getJustification().name()).isEqualTo(AnalysisJustification.CODE_NOT_REACHABLE.name());
                    assertThat(vulnerabilityPolicy.getAnalysis().getDetails()).isEqualTo("something");
                    assertThat(vulnerabilityPolicy.getRatings()).isNotNull();
                    assertThat(vulnerabilityPolicy.getRatings()).hasSize(1);
                    assertThat(vulnerabilityPolicy.getRatings()).satisfiesExactlyInAnyOrder(
                            rating1 -> {
                                assertThat(rating1.getScore()).isEqualTo(6.3);
                                assertThat(rating1.getMethod()).isEqualTo(VulnerabilityPolicyRating.Method.CVSSV3);
                                assertThat(rating1.getSeverity()).isEqualTo(VulnerabilityPolicyRating.Severity.HIGH);
                                assertThat(rating1.getVector()).isEqualTo("CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L");
                            });
                });
    }

    @Test
    public void testGetVulnerabilityPolicyByName() throws Exception {

        VulnerabilityPolicy vulnPolicy = getVulnerabilityPolicyInstance();

        final int count = JdbiFactory.jdbi(qm).withExtension(VulnerabilityPolicyDao.class,
                dao -> dao.createVulnerabilityPolicy(vulnPolicy));

        assertThat(count).isEqualTo(1);

        VulnerabilityPolicy vulnerabilityPolicy = JdbiFactory.jdbi(qm).withExtension(VulnerabilityPolicyDao.class,
                dao -> dao.getVulnerabilityPolicyByName("name"));

        assertNotNull(vulnerabilityPolicy);
        assertThat(vulnerabilityPolicy).isNotNull();
        assertThat(vulnerabilityPolicy.getCreated()).isNotNull();
        assertThat(vulnerabilityPolicy.getConditions()).isEqualTo(vulnPolicy.getConditions());
        assertThat(vulnerabilityPolicy.getAnalysis()).isNotNull();
        assertThat(vulnerabilityPolicy.getAnalysis().getState().name()).isEqualTo(AnalysisState.NOT_AFFECTED.name());
        assertThat(vulnerabilityPolicy.getAnalysis().isSuppress()).isTrue();
        assertThat(vulnerabilityPolicy.getAnalysis().getJustification().name()).isEqualTo(AnalysisJustification.CODE_NOT_REACHABLE.name());
        assertThat(vulnerabilityPolicy.getAnalysis().getDetails()).isEqualTo("something");
        assertThat(vulnerabilityPolicy.getRatings()).isNotNull();
        assertThat(vulnerabilityPolicy.getRatings()).hasSize(1);
        assertThat(vulnerabilityPolicy.getRatings()).satisfiesExactlyInAnyOrder(
                rating1 -> {
                    assertThat(rating1.getScore()).isEqualTo(6.3);
                    assertThat(rating1.getMethod()).isEqualTo(VulnerabilityPolicyRating.Method.CVSSV3);
                    assertThat(rating1.getSeverity()).isEqualTo(VulnerabilityPolicyRating.Severity.HIGH);
                    assertThat(rating1.getVector()).isEqualTo("CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L");
                });

    }

    @Test
    public void testDeleteVulnerabilityPolicyByName() throws Exception {

        VulnerabilityPolicy vulnPolicy = getVulnerabilityPolicyInstance();

        final int count = JdbiFactory.jdbi(qm).withExtension(VulnerabilityPolicyDao.class,
                dao -> dao.createVulnerabilityPolicy(vulnPolicy));

        assertThat(count).isEqualTo(1);

        VulnerabilityPolicy vulnerabilityPolicy = JdbiFactory.jdbi(qm).withExtension(VulnerabilityPolicyDao.class,
                dao -> dao.getVulnerabilityPolicyByName("name"));

        assertNotNull(vulnerabilityPolicy);

        final int result = JdbiFactory.jdbi(qm).withExtension(VulnerabilityPolicyDao.class,
                dao -> dao.deleteVulnerabilityPolicyByName("name"));

        assertThat(result).isEqualTo(1);
    }

    @Test
    public void testUpdateVulnerabilityPolicyByName() throws Exception {

        VulnerabilityPolicy vulnPolicy = getVulnerabilityPolicyInstance();

        final int count = JdbiFactory.jdbi(qm).withExtension(VulnerabilityPolicyDao.class,
                dao -> dao.createVulnerabilityPolicy(vulnPolicy));

        assertThat(count).isEqualTo(1);

        VulnerabilityPolicy vulnerabilityPolicy = JdbiFactory.jdbi(qm).withExtension(VulnerabilityPolicyDao.class,
                dao -> dao.getVulnerabilityPolicyByName("name"));

        assertNotNull(vulnerabilityPolicy);
        vulnPolicy.setAuthor("Jon Doe");

        int updatedCount = JdbiFactory.jdbi(qm).withExtension(VulnerabilityPolicyDao.class,
                dao -> dao.updateVulnerabilityPolicyByName(vulnPolicy));

        assertThat(updatedCount).isEqualTo(1);

        VulnerabilityPolicy updatedPolicy = JdbiFactory.jdbi(qm).withExtension(VulnerabilityPolicyDao.class,
                dao -> dao.getVulnerabilityPolicyByName("name"));

        assertThat(updatedPolicy).isNotNull();
        assertThat(updatedPolicy.getCreated()).isNotNull();
        assertThat(updatedPolicy.getAuthor()).isEqualTo("Jon Doe");
        assertThat(updatedPolicy.getConditions()).isEqualTo(vulnPolicy.getConditions());
        assertThat(updatedPolicy.getAnalysis()).isNotNull();
        assertThat(updatedPolicy.getAnalysis().getState().name()).isEqualTo(AnalysisState.NOT_AFFECTED.name());
        assertThat(updatedPolicy.getAnalysis().isSuppress()).isTrue();
        assertThat(updatedPolicy.getAnalysis().getJustification().name()).isEqualTo(AnalysisJustification.CODE_NOT_REACHABLE.name());
        assertThat(updatedPolicy.getAnalysis().getDetails()).isEqualTo("something");
        assertThat(updatedPolicy.getRatings()).isNotNull();
        assertThat(updatedPolicy.getRatings()).hasSize(1);
        assertThat(updatedPolicy.getRatings()).satisfiesExactlyInAnyOrder(
                rating1 -> {
                    assertThat(rating1.getScore()).isEqualTo(6.3);
                    assertThat(rating1.getMethod()).isEqualTo(VulnerabilityPolicyRating.Method.CVSSV3);
                    assertThat(rating1.getSeverity()).isEqualTo(VulnerabilityPolicyRating.Severity.HIGH);
                    assertThat(rating1.getVector()).isEqualTo("CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L");
                });

    }
}
