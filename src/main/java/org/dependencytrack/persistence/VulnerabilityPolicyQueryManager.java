package org.dependencytrack.persistence;

import alpine.common.logging.Logger;
import alpine.persistence.OrderDirection;
import alpine.persistence.PaginatedResult;
import alpine.resources.AlpineRequest;
import alpine.server.util.DbUtil;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsonorg.JsonOrgModule;
import org.apache.commons.lang3.tuple.Pair;
import org.dependencytrack.model.VulnerabilityPolicy;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicyAnalysis;
import org.json.JSONArray;
import org.json.JSONObject;

import javax.jdo.PersistenceManager;
import java.sql.Array;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

public class VulnerabilityPolicyQueryManager extends QueryManager implements IQueryManager {
    private static final Logger LOGGER = Logger.getLogger(VulnerabilityPolicyQueryManager.class);

    private static final ObjectMapper MAPPER = new ObjectMapper().registerModule(new JsonOrgModule());

    VulnerabilityPolicyQueryManager(final PersistenceManager pm) {
        super(pm);
    }

    VulnerabilityPolicyQueryManager(final PersistenceManager pm, final AlpineRequest request) {
        super(pm, request);
    }

    @Override
    public int createVulnerabilityPolicy(VulnerabilityPolicy vulnerabilityPolicy, Connection connection) {
        String createQuery = """
                INSERT INTO "VULNERABILITY_POLICY"(
                	"ANALYSIS", "AUTHOR", "CONDITIONS", "CREATED", "DESCRIPTION", "NAME", "RATINGS", "VALID_FROM", "VALID_UNTIL")
                	VALUES (?::JSON, ?, ?, ?, ?, ?, ?::JSON, ?, ?);
                """;
        PreparedStatement preparedStatement = null;
        Connection localConnection = null;
        Array conditions = null;
        try {
            String analysis = MAPPER.writeValueAsString(vulnerabilityPolicy.getAnalysis());
            String ratings = MAPPER.writeValueAsString(vulnerabilityPolicy.getRatings());
            if (connection == null) {
                localConnection = (Connection) pm.getDataStoreConnection();
                preparedStatement = localConnection.prepareStatement(createQuery);
                conditions = localConnection.createArrayOf("text", vulnerabilityPolicy.getConditions());
            } else {
                preparedStatement = connection.prepareStatement(createQuery);
                conditions = connection.createArrayOf("text", vulnerabilityPolicy.getConditions());
            }
            preparedStatement.setObject(1, analysis);
            preparedStatement.setString(2, vulnerabilityPolicy.getAuthor());
            preparedStatement.setArray(3, conditions);
            preparedStatement.setTimestamp(4, vulnerabilityPolicy.getCreated() != null ? new java.sql.Timestamp(vulnerabilityPolicy.getCreated().getTime()) : null);
            preparedStatement.setString(5, vulnerabilityPolicy.getDescription());
            preparedStatement.setString(6, vulnerabilityPolicy.getName());
            preparedStatement.setObject(7, ratings);
            preparedStatement.setTimestamp(8, vulnerabilityPolicy.getValidFrom() != null ? new java.sql.Timestamp(vulnerabilityPolicy.getValidFrom().getTime()) : null);
            preparedStatement.setTimestamp(9, vulnerabilityPolicy.getValidUntil() != null ? new java.sql.Timestamp(vulnerabilityPolicy.getValidUntil().getTime()) : null);

            return preparedStatement.executeUpdate();
        } catch (Exception ex) {
            LOGGER.error("Error in creating vulnerability policy", ex);
            throw new RuntimeException(ex);
        } finally {
            DbUtil.close(preparedStatement);
            if (localConnection != null) {
                DbUtil.close(localConnection);
            }
        }
    }

    @Override
    public List<VulnerabilityPolicy> getAllVulnerabilityPolicies() {
        String selectQuery = """
                SELECT "ID", "ANALYSIS", "AUTHOR", "CONDITIONS", "CREATED", "DESCRIPTION", "NAME", "RATINGS", "UPDATED", "VALID_FROM", "VALID_UNTIL"
                	FROM "VULNERABILITY_POLICY";
                """;

        Connection connection = null;
        PreparedStatement preparedStatement = null;
        ArrayList vulnerabilityPolicies = new ArrayList<VulnerabilityPolicy>();
        try {
            connection = (Connection) pm.getDataStoreConnection();
            preparedStatement = connection.prepareStatement(selectQuery);
            ResultSet rs = preparedStatement.executeQuery();
            while (rs.next()) {
                VulnerabilityPolicy vulnerabilityPolicy = mapVulnerabilityPolicyResultSet(rs);
                vulnerabilityPolicies.add(vulnerabilityPolicy);
            }
        } catch (Exception ex) {
            LOGGER.error("Error in getting all vulnerability policies", ex);
            throw new RuntimeException(ex);
        } finally {
            DbUtil.close(preparedStatement);
            DbUtil.close(connection);
        }
        return vulnerabilityPolicies;
    }


    public PaginatedResult getAllVulnerabilityPolicies(String name, Date validFrom, Date validUntil) {

        String selectQuery = """
                SELECT "ID", "ANALYSIS", "AUTHOR", "CONDITIONS", "CREATED", "DESCRIPTION", "NAME", "RATINGS", "UPDATED", "VALID_FROM", "VALID_UNTIL", COUNT(*) OVER() AS "totalCount"
                FROM "VULNERABILITY_POLICY"
                """;
        Pair<ArrayList, Map<String, Object>> queryFilterAndParamsPair = buildQueryFilterParams(name, validFrom, validUntil);
        selectQuery += String.join(" ", queryFilterAndParamsPair.getLeft());
        selectQuery += buildOrderBySubQuery();
        selectQuery = addPaginationToQuery(selectQuery);

        Map<String, Object> queryParams = queryFilterAndParamsPair.getRight();

        Connection connection = null;
        PreparedStatement preparedStatement = null;
        ResultSet rs = null;
        int totalCount = 0;
        ArrayList vulnerabilityPolicies = new ArrayList<VulnerabilityPolicy>();
        try {
            connection = (Connection) pm.getDataStoreConnection();
            preparedStatement = connection.prepareStatement(selectQuery);

            if (!queryParams.isEmpty()) {
                int position = 0;
                for (var entry : queryParams.entrySet()) {
                    if ("NAME".equalsIgnoreCase(entry.getKey())) {
                        preparedStatement.setString(++position, (String) entry.getValue());
                    } else if ("VALID_FROM".equalsIgnoreCase(entry.getKey()) || "VALID_UNTIL".equalsIgnoreCase(entry.getKey())) {
                        preparedStatement.setTimestamp(++position, new java.sql.Timestamp(((Date) entry.getValue()).getTime()));
                    }
                }
            }

            rs = preparedStatement.executeQuery();
            while (rs.next()) {
                VulnerabilityPolicy vulnerabilityPolicy = mapVulnerabilityPolicyResultSet(rs);
                totalCount = rs.getInt("totalCount");
                vulnerabilityPolicies.add(vulnerabilityPolicy);
            }
        } catch (Exception ex) {
            LOGGER.error("Error in fetching paginated vulnerability policies", ex);
            throw new RuntimeException(ex);
        } finally {
            DbUtil.close(preparedStatement);
            DbUtil.close(connection);
        }
        return (new PaginatedResult()).objects(vulnerabilityPolicies).total(totalCount);
    }

    @Override
    public VulnerabilityPolicy getVulnerabilityPolicyByName(String name) {
        String selectQuery = """
                SELECT "ID", "ANALYSIS", "AUTHOR", "CONDITIONS", "CREATED", "DESCRIPTION", "NAME", "RATINGS", "UPDATED", "VALID_FROM", "VALID_UNTIL"
                	FROM "VULNERABILITY_POLICY" WHERE "NAME" = ?;
                """;

        Connection connection = null;
        PreparedStatement preparedStatement = null;
        VulnerabilityPolicy vulnerabilityPolicy = new VulnerabilityPolicy();
        try {
            connection = (Connection) pm.getDataStoreConnection();
            preparedStatement = connection.prepareStatement(selectQuery);
            preparedStatement.setString(1, name);
            ResultSet rs = preparedStatement.executeQuery();
            while (rs.next()) {
                vulnerabilityPolicy = mapVulnerabilityPolicyResultSet(rs);
            }
        } catch (Exception ex) {
            LOGGER.error("Error in getting vulnerability policy by name", ex);
            throw new RuntimeException(ex);
        } finally {
            DbUtil.close(preparedStatement);
            DbUtil.close(connection);
        }
        return vulnerabilityPolicy;
    }

    @Override
    public int deleteVulnerabilityPolicyByName(String vulnerabilityPolicyName, Connection connection) {
        Connection localConnection = null;
        //Name is unique
        String deleteQuery = """
                DELETE FROM "VULNERABILITY_POLICY" WHERE "NAME" = ?;
                """;
        PreparedStatement preparedStatement = null;
        try {
            if (connection == null) {
                localConnection = (Connection) pm.getDataStoreConnection();
                preparedStatement = localConnection.prepareStatement(deleteQuery);
            } else {
                preparedStatement = connection.prepareStatement(deleteQuery);
            }
            preparedStatement.setString(1, vulnerabilityPolicyName);
            return preparedStatement.executeUpdate();
        } catch (Exception ex) {
            LOGGER.error("Error in deleting vulnerability policy", ex);
            throw new RuntimeException(ex);
        } finally {
            DbUtil.close(preparedStatement);
            if (localConnection != null) {
                DbUtil.close(localConnection);
            }
        }
    }

    public int updateVulnerabilityPolicyByName(VulnerabilityPolicy vulnerabilityPolicy, Connection connection) {
        String createQuery = """
                UPDATE "VULNERABILITY_POLICY"
                	SET "ANALYSIS"=?::JSON, "AUTHOR"=?, "CONDITIONS"=?, "DESCRIPTION"=?, "RATINGS"=?::JSON, "UPDATED"=?, "VALID_FROM"=?, "VALID_UNTIL"=?
                	WHERE "NAME" = ?;
                                """;
        PreparedStatement preparedStatement = null;
        Connection localConnection = null;
        Array conditions = null;
        try {
            String analysis = MAPPER.writeValueAsString(vulnerabilityPolicy.getAnalysis());
            String ratings = MAPPER.writeValueAsString(vulnerabilityPolicy.getRatings());
            if (connection == null) {
                localConnection = (Connection) pm.getDataStoreConnection();
                preparedStatement = localConnection.prepareStatement(createQuery);
                conditions = localConnection.createArrayOf("text", vulnerabilityPolicy.getConditions());
            } else {
                preparedStatement = connection.prepareStatement(createQuery);
                conditions = connection.createArrayOf("text", vulnerabilityPolicy.getConditions());
            }
            preparedStatement.setObject(1, analysis);
            preparedStatement.setString(2, vulnerabilityPolicy.getAuthor());
            preparedStatement.setArray(3, conditions);
            preparedStatement.setString(4, vulnerabilityPolicy.getDescription());
            preparedStatement.setObject(5, ratings);
            preparedStatement.setTimestamp(6, vulnerabilityPolicy.getUpdated() != null ? new java.sql.Timestamp(vulnerabilityPolicy.getUpdated().getTime()) : null);
            preparedStatement.setTimestamp(7, vulnerabilityPolicy.getValidFrom() != null ? new java.sql.Timestamp(vulnerabilityPolicy.getValidFrom().getTime()) : null);
            preparedStatement.setTimestamp(8, vulnerabilityPolicy.getValidUntil() != null ? new java.sql.Timestamp(vulnerabilityPolicy.getValidUntil().getTime()) : null);
            preparedStatement.setString(9, vulnerabilityPolicy.getName());

            return preparedStatement.executeUpdate();
        } catch (Exception ex) {
            LOGGER.error("Error in creating vulnerability policy", ex);
            throw new RuntimeException(ex);
        } finally {
            DbUtil.close(preparedStatement);
            if (localConnection != null) {
                DbUtil.close(localConnection);
            }
        }
    }

    private String buildOrderBySubQuery() {
        String orderBySubQuery = null;
        if (orderBy == null) {
            orderBySubQuery =
                    """
                                ORDER BY "NAME" 
                            """;
        } else {
            orderBySubQuery =
                    "ORDER BY " + "\"" + mapFieldName(orderBy) + "\"";
        }
        if (orderDirection == OrderDirection.ASCENDING) {
            orderBySubQuery += " ASC ";
        } else if (orderDirection == OrderDirection.DESCENDING) {
            orderBySubQuery += " DESC ";
        }
        orderBySubQuery += """
                , "ID"
                """;
        return orderBySubQuery;
    }

    private static String mapFieldName(String fieldName) {
        if (fieldName == null) {
            return null;
        }
        return switch (fieldName.toUpperCase()) {
            case "AUTHOR", "CREATED", "VALID_FROM", "VALID_UNTIL" -> fieldName.toUpperCase();
            default -> throw new IllegalArgumentException("Ordering not supported");
        };
    }

    private String addPaginationToQuery(final String query) {
        if (pagination != null && pagination.isPaginated()) {
            return query +
                    """
                                OFFSET %d
                                LIMIT %d;
                            """.formatted(pagination.getOffset(), pagination.getLimit());
        }
        return query;
    }

    private static VulnerabilityPolicy mapVulnerabilityPolicyResultSet(ResultSet rs) throws SQLException {
        VulnerabilityPolicy vulnerabilityPolicy = new VulnerabilityPolicy();
        vulnerabilityPolicy.setId(rs.getLong("ID"));
        JSONObject analysisJson = new JSONObject(rs.getString("ANALYSIS"));
        vulnerabilityPolicy.setAnalysis(MAPPER.convertValue(analysisJson, VulnerabilityPolicyAnalysis.class));
        vulnerabilityPolicy.setAuthor(rs.getString("AUTHOR"));
        Array conditions = rs.getArray("CONDITIONS");
        vulnerabilityPolicy.setConditions((String[]) conditions.getArray());
        vulnerabilityPolicy.setCreated(rs.getTimestamp("CREATED"));
        vulnerabilityPolicy.setDescription(rs.getString("DESCRIPTION"));
        vulnerabilityPolicy.setName(rs.getString("NAME"));
        JSONArray ratingsJson = new JSONArray(rs.getString("RATINGS"));
        vulnerabilityPolicy.setRatings(MAPPER.convertValue(ratingsJson, new TypeReference<>() {
        }));
        vulnerabilityPolicy.setUpdated(rs.getTimestamp("UPDATED"));
        vulnerabilityPolicy.setValidFrom(rs.getTimestamp("VALID_FROM"));
        vulnerabilityPolicy.setValidUntil(rs.getTimestamp("VALID_UNTIL"));
        return vulnerabilityPolicy;
    }

    private static Pair<ArrayList, Map<String, Object>> buildQueryFilterParams(String name, Date validFrom, Date validUntil) {
        ArrayList<String> queryFilterElements = new ArrayList<>();
        Map<String, Object> queryParams = new LinkedHashMap<>();

        if (name != null || validFrom != null || validUntil != null) {
            queryFilterElements.add("WHERE ");
            if (name != null) {
                queryFilterElements.add("\"NAME\" = ? ");
                queryParams.put("NAME", name);
            }
            if (validFrom != null) {
                if (queryParams.isEmpty()) {
                    queryFilterElements.add(" \"VALID_FROM\" >= ? ");
                } else {
                    queryFilterElements.add(" AND \"VALID_FROM\" >= ? ");
                }
                queryParams.put("VALID_FROM", validFrom);
            }
            if (validUntil != null) {
                if (queryParams.isEmpty()) {
                    queryFilterElements.add(" \"VALID_UNTIL\" <= ? ");
                } else {
                    queryFilterElements.add(" AND \"VALID_UNTIL\" <= ? ");
                }
                queryParams.put("VALID_UNTIL", validUntil);
            }
        }
        return Pair.of(queryFilterElements, queryParams);
    }
}
