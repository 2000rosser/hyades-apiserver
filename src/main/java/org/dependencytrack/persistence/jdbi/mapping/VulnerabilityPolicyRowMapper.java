package org.dependencytrack.persistence.jdbi.mapping;

import com.fasterxml.jackson.core.type.TypeReference;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicy;
import org.jdbi.v3.core.mapper.RowMapper;
import org.jdbi.v3.core.statement.StatementContext;

import java.sql.ResultSet;
import java.sql.SQLException;

import static org.dependencytrack.persistence.jdbi.mapping.RowMapperUtil.deserializeJson;
import static org.dependencytrack.persistence.jdbi.mapping.RowMapperUtil.maybeGet;
import static org.dependencytrack.persistence.jdbi.mapping.RowMapperUtil.nullableZonedDateTime;
import static org.dependencytrack.persistence.jdbi.mapping.RowMapperUtil.stringArray;

public class VulnerabilityPolicyRowMapper implements RowMapper<VulnerabilityPolicy> {

    @Override
    public VulnerabilityPolicy map(final ResultSet rs, final StatementContext ctx) throws SQLException {
        VulnerabilityPolicy vulnerabilityPolicy = new VulnerabilityPolicy();
        vulnerabilityPolicy.setAnalysis(deserializeJson(rs, "ANALYSIS", new TypeReference<>() {}));
        vulnerabilityPolicy.setRatings(deserializeJson(rs, "RATINGS", new TypeReference<>() {}));
        vulnerabilityPolicy.setUpdated(nullableZonedDateTime(rs, "UPDATED"));
        vulnerabilityPolicy.setCreated(nullableZonedDateTime(rs, "CREATED"));
        vulnerabilityPolicy.setValidFrom(nullableZonedDateTime(rs, "VALID_FROM"));
        vulnerabilityPolicy.setValidUntil(nullableZonedDateTime(rs, "VALID_UNTIL"));
        vulnerabilityPolicy.setAuthor(maybeGet(rs, "AUTHOR", ResultSet::getString));
        vulnerabilityPolicy.setConditions(stringArray(rs, "CONDITIONS"));
        vulnerabilityPolicy.setDescription(maybeGet(rs, "DESCRIPTION", ResultSet::getString));
        vulnerabilityPolicy.setName(maybeGet(rs, "NAME", ResultSet::getString));
        return vulnerabilityPolicy;
    }
}
