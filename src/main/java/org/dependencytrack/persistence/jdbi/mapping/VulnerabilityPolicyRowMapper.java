package org.dependencytrack.persistence.jdbi.mapping;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsonorg.JsonOrgModule;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicy;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicyAnalysis;
import org.jdbi.v3.core.mapper.RowMapper;
import org.jdbi.v3.core.statement.StatementContext;

import java.sql.Array;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.time.ZoneOffset;
import java.util.Arrays;
import java.util.Optional;

public class VulnerabilityPolicyRowMapper implements RowMapper<VulnerabilityPolicy> {

    private static final ObjectMapper MAPPER = new ObjectMapper().registerModule(new JsonOrgModule());

    @Override
    public VulnerabilityPolicy map(final ResultSet rs, final StatementContext ctx) throws SQLException {
        VulnerabilityPolicy vulnerabilityPolicy = new VulnerabilityPolicy();
        try {
            vulnerabilityPolicy.setAnalysis(MAPPER.readValue(rs.getString("ANALYSIS"), VulnerabilityPolicyAnalysis.class));
        } catch(Exception ex) {
            throw new SQLException("Unable to map Analysis column from database", ex);
        }
        Optional.ofNullable(rs.getString("RATINGS")).ifPresent(ratings -> {
            try {
                vulnerabilityPolicy.setRatings(MAPPER.readValue(ratings, new TypeReference<>() {
                }));
            } catch (JsonProcessingException e) {
                throw new RuntimeException("Unable to map vulnerability policy" , e);
            }
        });
        Optional.ofNullable(rs.getDate("UPDATED")).ifPresent(date ->
                vulnerabilityPolicy.setUpdated(date.toLocalDate().atStartOfDay(ZoneOffset.UTC)));
        Optional.ofNullable(rs.getDate("CREATED")).ifPresent(date -> {
            vulnerabilityPolicy.setCreated(date.toLocalDate().atStartOfDay(ZoneOffset.UTC));
        });
        Optional.ofNullable(rs.getDate("VALID_FROM")).ifPresent(date -> {
            vulnerabilityPolicy.setValidFrom(date.toLocalDate().atStartOfDay(ZoneOffset.UTC));
        });
        Optional.ofNullable(rs.getDate("VALID_UNTIL")).ifPresent(date -> {
            vulnerabilityPolicy.setValidUntil(date.toLocalDate().atStartOfDay(ZoneOffset.UTC));
        });
        vulnerabilityPolicy.setAuthor(rs.getString("AUTHOR"));
        Array conditions = rs.getArray("CONDITIONS");
        vulnerabilityPolicy.setConditions(Arrays.stream(((String[]) conditions.getArray())).toList());
        vulnerabilityPolicy.setDescription(rs.getString("DESCRIPTION"));
        vulnerabilityPolicy.setName(rs.getString("NAME"));
        return vulnerabilityPolicy;
    }
}
