package org.dependencytrack.tasks.vulnerabilitypolicy.blobstorage;

import alpine.Config;
import org.dependencytrack.common.ConfigKey;
import org.dependencytrack.tasks.vulnerabilitypolicy.S3Client;
import org.dependencytrack.util.VulnerabilityPolicyUtil;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.util.NoSuchElementException;
import java.util.zip.ZipInputStream;

public class S3StorageHandler implements BlobStorageAccessHandler {
    private final S3Client s3Client;

    public S3StorageHandler() {
        this.s3Client = new S3Client(Config.getInstance().getProperty(ConfigKey.VULNERABILITY_POLICY_BUNDLE_URL), Config.getInstance().getProperty(ConfigKey.VULNERABILITY_POLICY_S3_BUNDLE_NAME),
                Config.getInstance().getProperty(ConfigKey.VULNERABILITY_POLICY_S3_ACCESS_KEY), Config.getInstance().getProperty(ConfigKey.VULNERABILITY_POLICY_S3_SECRET_KEY),
                Config.getInstance().getProperty(ConfigKey.VULNERABILITY_POLICY_S3_BUCKET_NAME), Config.getInstance().getProperty(ConfigKey.VULNERABILITY_POLICY_S3_REGION));
    }

    S3StorageHandler(S3Client s3Client) {
        this.s3Client = s3Client;
    }

    @Override
    public boolean verifyDownloadNeeded() throws IOException {
        if (s3Client.doesBucketExist()) {
            //perform head request check on the object of interest
            return VulnerabilityPolicyUtil.matchWithHashConfigProperty(s3Client.getObjectEtag());
        } else {
            throw new NoSuchElementException("Provided bucket %s not found in the s3 bucket".formatted(s3Client.getS3BucketName()));
        }
    }

    @Override
    public ZipInputStream downloadZippedContent() throws IOException {
        return new ZipInputStream(new ByteArrayInputStream(s3Client.getObject()));
    }

}
