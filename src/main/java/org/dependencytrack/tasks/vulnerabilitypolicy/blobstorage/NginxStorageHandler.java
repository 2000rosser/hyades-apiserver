package org.dependencytrack.tasks.vulnerabilitypolicy.blobstorage;

import alpine.Config;
import alpine.common.logging.Logger;
import org.apache.http.Header;
import org.apache.http.HttpEntity;
import org.apache.http.HttpStatus;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpHead;
import org.apache.http.client.methods.HttpUriRequest;
import org.apache.http.impl.client.CloseableHttpClient;
import org.dependencytrack.common.ConfigKey;
import org.dependencytrack.common.HttpClientPool;
import org.dependencytrack.util.HttpUtil;
import org.dependencytrack.util.VulnerabilityPolicyUtil;

import java.io.IOException;
import java.util.Arrays;
import java.util.Optional;
import java.util.zip.ZipInputStream;

public class NginxStorageHandler implements BlobStorageAccessHandler {

    private static final Logger LOGGER = Logger.getLogger(NginxStorageHandler.class);
    protected String username;
    protected String password;
    protected final CloseableHttpClient httpClient = HttpClientPool.getClient();

    void setUsername() {
        if (Config.getInstance().getProperty(ConfigKey.VULNERABILITY_POLICY_BUNDLE_AUTH_USERNAME) != null) {
            this.username = Config.getInstance().getProperty(ConfigKey.VULNERABILITY_POLICY_BUNDLE_AUTH_USERNAME);
        }
    }

    void setPassword() {
        if (Config.getInstance().getProperty(ConfigKey.VULNERABILITY_POLICY_BUNDLE_AUTH_PASSWORD) != null) {
            this.password = Config.getInstance().getProperty(ConfigKey.VULNERABILITY_POLICY_BUNDLE_AUTH_PASSWORD);
        }
    }

    public NginxStorageHandler() {
        setUsername();
        setPassword();
    }

    CloseableHttpResponse performHeadRequest() throws IOException {
        HttpUriRequest request = new HttpHead(Config.getInstance().getProperty(ConfigKey.VULNERABILITY_POLICY_BUNDLE_URL));
        if (username != null || password != null) {
            request.addHeader("Authorization", HttpUtil.basicAuthHeaderValue(username, password));
        }
        return httpClient.execute(request);
    }

    CloseableHttpResponse performGetRequest() throws IOException {
        HttpUriRequest request = new HttpGet(Config.getInstance().getProperty(ConfigKey.VULNERABILITY_POLICY_BUNDLE_URL));
        if (username != null || password != null) {
            request.addHeader("Authorization", HttpUtil.basicAuthHeaderValue(username, password));
        }
        return httpClient.execute(request);
    }

    @Override
    public boolean verifyDownloadNeeded() throws IOException {
        try (CloseableHttpResponse response = performHeadRequest()) {
            if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {
                Header[] httpHeaders = response.getAllHeaders();
                Optional<Header> headerOptional = Arrays.stream(httpHeaders).filter(header -> header.getName().equalsIgnoreCase("ETag")).findFirst();
                if (headerOptional.isPresent()) {
                    return VulnerabilityPolicyUtil.matchWithHashConfigProperty(headerOptional.get().getValue());
                } else {
                    LOGGER.warn("Was not able to find Etag header in the nginx request. Will proceed assuming that file needs to be downloaded");
                    return true;
                }
            } else {
                throw new IOException(("Unable to get response from resource bundle endpoint for policy." +
                        " Response code received: %s. Response messge: %s").
                        formatted(response.getStatusLine().getStatusCode(), response.getStatusLine().getReasonPhrase()));

            }
        }
    }

    @Override
    public ZipInputStream downloadZippedContent() throws IOException {
        CloseableHttpResponse response = performGetRequest();
        HttpEntity entity = response.getEntity();
        return new ZipInputStream(entity.getContent());
    }

}
