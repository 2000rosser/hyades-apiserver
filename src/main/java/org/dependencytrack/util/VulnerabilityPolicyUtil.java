package org.dependencytrack.util;

import alpine.common.logging.Logger;
import alpine.model.ConfigProperty;
import alpine.server.util.DbUtil;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;
import com.fasterxml.jackson.datatype.jsonorg.JsonOrgModule;
import com.networknt.schema.JsonSchema;
import com.networknt.schema.JsonSchemaFactory;
import com.networknt.schema.SpecVersion;
import com.networknt.schema.ValidationMessage;
import org.dependencytrack.model.ConfigPropertyConstants;
import org.dependencytrack.model.VulnerabilityPolicy;
import org.dependencytrack.persistence.QueryManager;
import org.dependencytrack.policy.cel.CelPolicyScriptHost;
import org.dependencytrack.policy.cel.CelPolicyType;
import org.projectnessie.cel.tools.ScriptCreateException;
import org.projectnessie.cel.tools.ScriptException;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.sql.Connection;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import static org.apache.commons.io.IOUtils.resourceToString;

public class VulnerabilityPolicyUtil {
    private static final Logger logger = Logger.getLogger(VulnerabilityPolicyUtil.class);
    private static final ObjectMapper MAPPER = new ObjectMapper(new YAMLFactory()).registerModule(new JsonOrgModule());

    public static void parseVulnerabilityPolicy(StringBuilder out, List<VulnerabilityPolicy> createVulnerabilityPolicyList,
                                          List<VulnerabilityPolicy> updateVulnerabilityPolicyList, List<String> policyNames)
            throws ScriptCreateException, IOException {
        JsonSchema schema = enrichYamlOjMapperAndGetSchema();
        JsonNode jsonNode = null;
        jsonNode = MAPPER.readTree(out.toString());
        Set<ValidationMessage> validateMsg = schema.validate(jsonNode);
        if (validateMsg.isEmpty()) { //yaml file provided is valid and we can proceed to validate the cel policy
            //if cel policy is invalid, ScriptCreateException will be thrown that trickles back to inform
            validateVulnerabilityCelPolicy(MAPPER.convertValue(jsonNode.get("conditions"), ArrayList.class));
            VulnerabilityPolicy vulnerabilityPolicy = MAPPER.convertValue(jsonNode, VulnerabilityPolicy.class);
            if (vulnerabilityPolicy != null) {
                if (policyNames.contains(vulnerabilityPolicy.getName())) {
                    updateVulnerabilityPolicyList.add(vulnerabilityPolicy);
                } else {
                    createVulnerabilityPolicyList.add(vulnerabilityPolicy);
                }
            } else {
                logger.warn("Was not able to create vulnerability policy object successfully");
            }
        } else {
            StringBuilder errorMessage = new StringBuilder();
            for (var message : validateMsg) {
                errorMessage.append(message.getMessage()).append("\n");
            }
            logger.error("unable to compile cel policy correctly. Errors received:%s".formatted(errorMessage.toString()));
        }
    }

    private static void validateVulnerabilityCelPolicy(ArrayList vulnerabilityCelPolicyConditions) throws ScriptCreateException {
        if (!vulnerabilityCelPolicyConditions.isEmpty()) {
            for (var vulnerabilityPolicyCondition : vulnerabilityCelPolicyConditions) {
                try {
                    CelPolicyScriptHost.getInstance(CelPolicyType.VULNERABILITY).compile((String) vulnerabilityPolicyCondition, CelPolicyScriptHost.CacheMode.CACHE);
                } catch (ScriptCreateException ex) {
                    logger.warn("Unable to parse cel expression provided in vulnerability policy yaml file: ");
                    throw ex;
                }
            }
        }
    }


    public static void parseAndSavePolicies(ZipInputStream zipInputStream) throws ScriptException, IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(zipInputStream, StandardCharsets.UTF_8));
        ZipEntry zipEntry = zipInputStream.getNextEntry();
        List<VulnerabilityPolicy> createVulnerabilityPolicyList = new ArrayList<>();
        List<VulnerabilityPolicy> updateVulnerabilityPolicyList = new ArrayList<>();
        try (QueryManager queryManager = new QueryManager()) {
            List<VulnerabilityPolicy> existingVulnerabilityPolicies = queryManager.getAllVulnerabilityPolicies();
            List<String> policyNames = existingVulnerabilityPolicies.stream().map(VulnerabilityPolicy::getName).toList();
            while (zipEntry != null) {
                if (!(zipEntry.getName().startsWith(".") || zipEntry.getName().startsWith("_")) && (zipEntry.getName().contains(".yaml") || zipEntry.getName().contains(".yml"))) {
                    String line = null;
                    StringBuilder out = new StringBuilder();
                    while ((line = reader.readLine()) != null) {
                        out.append(line + '\n');
                    }
                    parseVulnerabilityPolicy(out, createVulnerabilityPolicyList, updateVulnerabilityPolicyList, policyNames);
                }
                zipEntry = zipInputStream.getNextEntry();
            }
            saveParsedVulnerabilities(queryManager, createVulnerabilityPolicyList, updateVulnerabilityPolicyList, policyNames);
        }
    }


    public static boolean matchWithHashConfigProperty(String etag) {
        try (QueryManager queryManager = new QueryManager()) {
            ConfigProperty lastModifiedHash = queryManager.getConfigProperty(ConfigPropertyConstants.VULNERABILITY_POLICY_FILE_LAST_MODIFIED_HASH.getGroupName(),
                    ConfigPropertyConstants.VULNERABILITY_POLICY_FILE_LAST_MODIFIED_HASH.getPropertyName());
            if (lastModifiedHash == null) {
                //lastmodified hash property is currently not in the db
                queryManager.createConfigProperty(ConfigPropertyConstants.VULNERABILITY_POLICY_FILE_LAST_MODIFIED_HASH.getGroupName(),
                        ConfigPropertyConstants.VULNERABILITY_POLICY_FILE_LAST_MODIFIED_HASH.getPropertyName(),
                        etag,
                        ConfigPropertyConstants.VULNERABILITY_POLICY_FILE_LAST_MODIFIED_HASH.getPropertyType(),
                        ConfigPropertyConstants.VULNERABILITY_POLICY_FILE_LAST_MODIFIED_HASH.getDescription());
                return true;
            } else if (lastModifiedHash.getPropertyValue() == null ||
                    !(etag.equals(lastModifiedHash.getPropertyValue()))) {
                //lastmodifiedhash value is either null or different from incoming value
                lastModifiedHash.setPropertyValue(etag);
                return true;
            }
            //the lastmodified hash is the same as the incoming value
            return false;
        }
    }

    public static void saveParsedVulnerabilities(QueryManager queryManager, List<VulnerabilityPolicy> createVulnerabilityPolicyList,
                                           List<VulnerabilityPolicy> updateVulnerabilityPolicyList,
                                           List<String> policyNames) {
        List<String> receivedPolicyNames = new ArrayList<>();
        for (var vulnerabilityPolicy : createVulnerabilityPolicyList) {
            receivedPolicyNames.add(vulnerabilityPolicy.getName());
        }
        for (var vulnerabilityPolicy : updateVulnerabilityPolicyList) {
            receivedPolicyNames.add(vulnerabilityPolicy.getName());
        }
        List<String> vulnerabilityPoliciesToBeDeleted = policyNames.stream()
                .filter(policyName -> !receivedPolicyNames.contains(policyName)).toList();
        queryManager.runInTransaction(() -> {
            Connection connection = null;
            try {
                connection = (Connection) queryManager.getPersistenceManager().getDataStoreConnection();
                for (var vulnerabilityPolicy : createVulnerabilityPolicyList) {
                    queryManager.createVulnerabilityPolicy(vulnerabilityPolicy, connection);
                }
                for (var vulnerabilityPolicy : updateVulnerabilityPolicyList) {
                    queryManager.updateVulnerablePolicyByName(vulnerabilityPolicy, connection);
                }
                for (var name : vulnerabilityPoliciesToBeDeleted) {
                    queryManager.deleteVulnerabilityPolicyByName(name, connection);
                }
            } finally {
                DbUtil.close(connection);
            }

        });
    }

    private static JsonSchema enrichYamlOjMapperAndGetSchema() throws IOException {
        final String jsonSchemaContent = resourceToString("/schema/vulnerability-policy-v1.schema.json", StandardCharsets.UTF_8);
        JsonSchemaFactory factory = JsonSchemaFactory.builder(JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V202012)).objectMapper(MAPPER).build();
        return factory.getSchema(jsonSchemaContent);
    }



}
