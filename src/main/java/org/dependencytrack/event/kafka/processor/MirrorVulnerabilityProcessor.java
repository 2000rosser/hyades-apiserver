package org.dependencytrack.event.kafka.processor;

import alpine.common.logging.Logger;
import alpine.event.framework.Event;
import com.github.packageurl.MalformedPackageURLException;
import com.github.packageurl.PackageURL;
import org.apache.commons.lang3.StringUtils;
import org.apache.kafka.streams.processor.api.Processor;
import org.apache.kafka.streams.processor.api.Record;
import org.cyclonedx.proto.v1_4.Bom;
import org.cyclonedx.proto.v1_4.ScoreMethod;
import org.cyclonedx.proto.v1_4.Source;
import org.dependencytrack.event.IndexEvent;
import org.dependencytrack.model.Cwe;
import org.dependencytrack.model.Severity;
import org.dependencytrack.model.Vulnerability;
import org.dependencytrack.model.VulnerabilityAlias;
import org.dependencytrack.model.VulnerableSoftware;
import org.dependencytrack.persistence.QueryManager;

import java.math.BigDecimal;
import java.sql.Date;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.atomic.AtomicReference;


public class MirrorVulnerabilityProcessor implements Processor<String, Bom, Void, Void> {

    private static final Logger LOGGER = Logger.getLogger(MirrorVulnerabilityProcessor.class);
    @Override
    public void process(final Record<String, Bom> record) {
        try (QueryManager qm = new QueryManager()) {
            LOGGER.debug("Synchronizing Mirrored Vulnerability : " + record.key());
            Bom bom = record.value();
            String key = record.key();
            String mirrorSource = key.substring(0, key.indexOf("/"));
            Vulnerability.Source source = Vulnerability.Source.valueOf(mirrorSource);
            final Vulnerability vulnerability = mapBomToVulnerability(qm, bom);
            final List<VulnerableSoftware> vsListOld = qm.detach(qm.getVulnerableSoftwareByVulnId(vulnerability.getSource(), vulnerability.getVulnId()));
            final Vulnerability synchronizedVulnerability = qm.synchronizeVulnerability(vulnerability, false);
            var cycloneVuln = bom.getVulnerabilities(0);
            if (!cycloneVuln.getReferencesList().isEmpty()) {
                cycloneVuln.getReferencesList().stream().forEach(reference -> {
                    final String alias = reference.getId();
                    final VulnerabilityAlias vulnerabilityAlias = new VulnerabilityAlias();

                    // OSV will use IDs of other vulnerability databases for its
                    // primary advisory ID (e.g. GHSA-45hx-wfhj-473x). We need to ensure
                    // that we don't falsely report GHSA IDs as stemming from OSV.
                    final Vulnerability.Source advisorySource = extractSource(cycloneVuln.getId(), cycloneVuln.getSource());
                    if (mirrorSource.equals("OSV")) {
                        switch (advisorySource) {
                            case NVD -> vulnerabilityAlias.setCveId(cycloneVuln.getId());
                            case GITHUB -> vulnerabilityAlias.setGhsaId(cycloneVuln.getId());
                            default -> vulnerabilityAlias.setOsvId(cycloneVuln.getId());
                        }
                    }
                    if (alias.startsWith("CVE") && Vulnerability.Source.NVD != advisorySource) {
                        vulnerabilityAlias.setCveId(alias);
                        qm.synchronizeVulnerabilityAlias(vulnerabilityAlias);
                    } else if (alias.startsWith("GHSA") && Vulnerability.Source.GITHUB != advisorySource) {
                        vulnerabilityAlias.setGhsaId(alias);
                        qm.synchronizeVulnerabilityAlias(vulnerabilityAlias);
                    }
                });
            }
            if (!cycloneVuln.getAffectsList().isEmpty()) {
                final List<VulnerableSoftware> vsList = new ArrayList<>();
                cycloneVuln.getAffectsList().stream().forEach(affect -> affect.getVersionsList().stream().forEach(version -> {
                    if (version.hasRange()) {
                        VulnerableSoftware vs = mapAffectedPackageToVulnerableSoftware(qm, bom, version.getRange(), affect.getRef());
                        if (vs != null) {
                            vsList.add(vs);
                        }
                    }
                }));
                qm.persist(vsList);
                qm.updateAffectedVersionAttributions(synchronizedVulnerability, vsList, source);
                var reconciledVsList = qm.reconcileVulnerableSoftware(synchronizedVulnerability, vsListOld, vsList, source);
                synchronizedVulnerability.setVulnerableSoftware(reconciledVsList);
            }
            qm.persist(synchronizedVulnerability);
        }
        Event.dispatch(new IndexEvent(IndexEvent.Action.COMMIT, Vulnerability.class));

    }

    public VulnerableSoftware mapAffectedPackageToVulnerableSoftware(final QueryManager qm, final Bom affectedPackage, String range, String bomRef) {
        AtomicReference<String> purlStr = new AtomicReference<>();
        if (!affectedPackage.getComponentsList().isEmpty()) {
            affectedPackage.getComponentsList().stream().forEach(component -> {
                if (component.getBomRef().equals(bomRef)) {
                    purlStr.set(component.getPurl());
                }
            });
        }
        if (purlStr.get() == null) {
            LOGGER.debug("No PURL provided for affected package  - skipping");
            return null;
        }

        final PackageURL purl;
        try {
            purl = new PackageURL(purlStr.get());
        } catch (MalformedPackageURLException e) {
            LOGGER.debug("Invalid PURL provided for affected package  - skipping", e);
            return null;
        }

        // Other sources do not populate the versionStartIncluding with 0.
        // Semantically, versionStartIncluding=null is equivalent to >=0.
        // Omit zero values here for consistency's sake.
        String versionStartIncluding = null;
        String versionStartExcluding = null;
        String versionEndIncluding = null;
        String versionEndExcluding = null;


        final String[] parts;
        if(range != null) {
            range = range.split("/")[1];
            if (range.contains("|")) {
                parts = Arrays.stream(range.split("\\|")).map(String::trim).toArray(String[]::new);
            } else {
                parts = Arrays.stream(range.split(" ")).map(String::trim).toArray(String[]::new);
            }
            for (String part : parts) {
                if (part.startsWith(">=") || part.startsWith("[")) {
                    versionStartIncluding = part.replace(">=", "").replace("[", "").trim();
                    if (versionStartIncluding.length() == 0 || versionStartIncluding.contains("*")) {
                        versionStartIncluding = null;
                    }
                } else if (part.startsWith(">") || part.startsWith("(")) {
                    versionStartExcluding = part.replace(">", "").replace("(", "").trim();
                    if (versionStartExcluding.length() == 0 || versionStartExcluding.contains("*")) {
                        versionStartIncluding = null;
                    }
                } else if (part.startsWith("<=") || part.endsWith("]")) {
                    versionEndIncluding = part.replace("<=", "").replace("]", "").trim();
                } else if (part.startsWith("<") || part.endsWith(")")) {
                    versionEndExcluding = part.replace("<", "").replace(")", "").trim();
                    if (versionEndExcluding.length() == 0 || versionEndExcluding.contains("*")) {
                        versionStartIncluding = null;
                    }
                } else if (part.startsWith("=")) {
                    versionStartIncluding = part.replace("=", "").trim();
                    versionEndIncluding = part.replace("=", "").trim();
                    if (versionStartIncluding.length() == 0 || versionStartIncluding.contains("*")) {
                        versionStartIncluding = null;
                    }
                    if (versionEndIncluding.length() == 0 || versionEndIncluding.contains("*")) {
                        versionStartIncluding = null;
                    }
                } else { //since we are not able to parse specific range, we do not want to end up with false positives and therefore this part will be skipped from being saved to db.
                    LOGGER.debug("Range not definite. Not saving this vulnerable software information. The purl was: " + purl);
                }
            }
        }


        VulnerableSoftware vs = qm.getVulnerableSoftwareByPurl(purl.getType(), purl.getNamespace(), purl.getName(),
                versionEndExcluding, versionEndIncluding, null, versionStartIncluding);
        if (vs != null) {
            return vs;
        }

        vs = new VulnerableSoftware();
        vs.setPurlType(purl.getType());
        vs.setPurlNamespace(purl.getNamespace());
        vs.setPurlName(purl.getName());
        vs.setPurl(purl.canonicalize());
        vs.setVulnerable(true);
        vs.setVersionStartIncluding(versionStartIncluding);
        vs.setVersionEndExcluding(versionEndExcluding);
        vs.setVersionEndIncluding(versionEndIncluding);
        return vs;
    }

    public Vulnerability mapBomToVulnerability(final QueryManager qm, final Bom bom) {
        org.cyclonedx.proto.v1_4.Vulnerability cycloneVuln = bom.getVulnerabilities(0);
        final Vulnerability vuln = new Vulnerability();
        if (cycloneVuln.getId() != null) {
            vuln.setSource(extractSource(cycloneVuln.getId(), cycloneVuln.getSource()));
        }
        vuln.setVulnId(cycloneVuln.getId());
        vuln.setTitle(StringUtils.abbreviate(cycloneVuln.getDescription(), 255));
        vuln.setDescription(cycloneVuln.getDetail());
        vuln.setPublished(Date.from(Instant.ofEpochSecond(cycloneVuln.getPublished().getSeconds())));
        vuln.setUpdated(Date.from(Instant.ofEpochSecond(cycloneVuln.getUpdated().getSeconds())));

        if (cycloneVuln.getCredits() != null) {
            vuln.setCredits(String.join(", ", cycloneVuln.getCredits().toString()));
        }
        final StringBuilder sb = new StringBuilder();
        if (!bom.getExternalReferencesList().isEmpty()) {
            bom.getExternalReferencesList().stream().forEach(externalReference -> {
                sb.append("* [").append(externalReference.getUrl()).append("](").append(externalReference.getUrl()).append(")\n");
            });
            vuln.setReferences(sb.toString());
        }
        if(!cycloneVuln.getAdvisoriesList().isEmpty()){
            cycloneVuln.getAdvisoriesList().stream().forEach(advisory -> {
                sb.append("* [").append(advisory.getUrl()).append("](").append(advisory.getUrl()).append(")\n");
            });
            vuln.setReferences(sb.toString());
        }


        if (!cycloneVuln.getCwesList().isEmpty()) {
            cycloneVuln.getCwesList().stream().forEach(cweId -> {
                final Cwe cwe = qm.getCweById(cweId);
                if (cwe != null) {
                    vuln.addCwe(cwe);
                }
            });
        }
        vuln.setSeverity(calculateSeverity(bom));
        if (!cycloneVuln.getRatingsList().isEmpty() && cycloneVuln.getRatings(0).getMethod() != null) {
            if (cycloneVuln.getRatings(0).getMethod().equals(ScoreMethod.SCORE_METHOD_CVSSV2)) {
                vuln.setCvssV2Vector(cycloneVuln.getRatings(0).getVector());
                vuln.setCvssV2BaseScore(BigDecimal.valueOf(cycloneVuln.getRatings(0).getScore()));
            }
            if (cycloneVuln.getRatings(0).getMethod().equals(ScoreMethod.SCORE_METHOD_CVSSV3)) {
                vuln.setCvssV3Vector(cycloneVuln.getRatings(0).getVector());
                vuln.setCvssV3BaseScore(BigDecimal.valueOf(cycloneVuln.getRatings(0).getScore()));
            }
        }
        return vuln;
    }

    public Severity calculateSeverity(Bom bom) {
        if (bom.getVulnerabilities(0) != null
                && !bom.getVulnerabilities(0).getRatingsList().isEmpty()
                && bom.getVulnerabilities(0).getRatings(0) != null) {
            org.cyclonedx.proto.v1_4.Severity severity =
                    bom.getVulnerabilities(0).getRatings(0).getSeverity();
            if (severity != null) {
                if (severity.equals(org.cyclonedx.proto.v1_4.Severity.SEVERITY_CRITICAL)) {
                    return Severity.CRITICAL;
                } else if (severity.equals(org.cyclonedx.proto.v1_4.Severity.SEVERITY_HIGH)) {
                    return Severity.HIGH;
                } else if (severity.equals(org.cyclonedx.proto.v1_4.Severity.SEVERITY_MEDIUM)) {
                    return Severity.MEDIUM;
                } else if (severity.equals(org.cyclonedx.proto.v1_4.Severity.SEVERITY_LOW)) {
                    return Severity.LOW;
                }
            }
        }
        return Severity.UNASSIGNED;
    }

    public Vulnerability.Source extractSource(String vulnId, Source source) {
        final String sourceId = vulnId.split("-")[0];
        return switch (sourceId) {
            case "GHSA" -> Vulnerability.Source.GITHUB;
            case "CVE" -> Vulnerability.Source.NVD;
            default -> source!= null ? Vulnerability.Source.valueOf(source.getName()) : Vulnerability.Source.INTERNAL;
        };
    }
}
