package org.dependencytrack.event.kafka.processor;

import alpine.common.logging.Logger;
import alpine.common.metrics.Metrics;
import alpine.model.ConfigProperty;
import alpine.notification.NotificationLevel;
import io.micrometer.core.instrument.Timer;
import org.apache.kafka.common.header.Header;
import org.apache.kafka.streams.processor.api.ContextualFixedKeyProcessor;
import org.apache.kafka.streams.processor.api.ContextualProcessor;
import org.apache.kafka.streams.processor.api.FixedKeyRecord;
import org.datanucleus.PropertyNames;
import org.dependencytrack.event.kafka.KafkaEventHeaders;
import org.dependencytrack.model.AnalyzerIdentity;
import org.dependencytrack.model.Component;
import org.dependencytrack.model.ConfigPropertyConstants;
import org.dependencytrack.model.FindingAttribution;
import org.dependencytrack.model.Vulnerability;
import org.dependencytrack.model.VulnerabilityAnalysisLevel;
import org.dependencytrack.notification.NotificationConstants;
import org.dependencytrack.notification.NotificationGroup;
import org.dependencytrack.notification.NotificationScope;
import org.dependencytrack.notification.vo.NewVulnerabilityIdentified;
import org.dependencytrack.parser.hyades.ModelConverter;
import org.dependencytrack.persistence.QueryManager;
import org.dependencytrack.util.NotificationUtil;
import org.dependencytrack.util.PersistenceUtil;
import org.hyades.proto.vulnanalysis.v1.ScanResult;
import org.hyades.proto.vulnanalysis.v1.ScanStatus;
import org.hyades.proto.vulnanalysis.v1.Scanner;
import org.hyades.proto.vulnanalysis.v1.ScannerResult;

import javax.jdo.Query;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.Set;
import java.util.UUID;
import java.util.function.Consumer;
import java.util.function.Function;

import static org.dependencytrack.util.NotificationUtil.dispatchExceptionNotifications;
import static org.dependencytrack.util.NotificationUtil.dispatchNotificationsWithSubject;
import static org.hyades.proto.vulnanalysis.v1.ScanStatus.SCAN_STATUS_FAILED;

/**
 * A {@link ContextualProcessor} responsible for processing {@link ScanResult}s.
 */
public class VulnerabilityScanResultProcessor extends ContextualFixedKeyProcessor<UUID, ScanResult, ScanResult> {

    private static final Logger LOGGER = Logger.getLogger(VulnerabilityScanResultProcessor.class);
    private static final Timer TIMER = Timer.builder("vuln_scan_result_processing")
            .description("Time taken to process vulnerability scan results")
            .register(Metrics.getRegistry());


    @Override
    public void process(final FixedKeyRecord<UUID, ScanResult> record) {
        final UUID componentUuid = record.key();
        final ScanResult result = record.value();
        final var scanKeyString = "%s/%s".formatted(result.getKey().getScanToken(), componentUuid);

        final Timer.Sample timerSample = Timer.start();
        try (final var qm = new QueryManager()) {
            qm.getPersistenceManager().setProperty(PropertyNames.PROPERTY_CACHE_L2_TYPE, "none");

            final Component component = qm.getObjectByUuid(Component.class, componentUuid);
            if (component == null) {
                LOGGER.warn("Received result for component %s, but it does not exist (scanKey: %s)"
                        .formatted(componentUuid, scanKeyString));
                return;
            }

            for (final ScannerResult scannerResult : result.getScannerResultsList()) {
                processScannerResult(qm, component, scanKeyString, scannerResult);
            }
        } finally {
            timerSample.stop(TIMER);
        }

        context().forward(record);
    }

    private void processScannerResult(final QueryManager qm, final Component component,
                                      final String scanKey, final ScannerResult scannerResult) {
        if (scannerResult.getStatus() == SCAN_STATUS_FAILED) {
            final var message = "Scan of component %s with %s failed (scanKey: %s): %s"
                    .formatted(component.getUuid(), scannerResult.getScanner(), scanKey, scannerResult.getFailureReason());
            dispatchExceptionNotifications(
                    NotificationScope.SYSTEM,
                    NotificationGroup.ANALYZER,
                    NotificationConstants.Title.ANALYZER_ERROR,
                    message,
                    NotificationLevel.ERROR);
            LOGGER.warn(message);
            return;
        } else if (scannerResult.getStatus() != ScanStatus.SCAN_STATUS_SUCCESSFUL) {
            LOGGER.warn("Unable to process results with status %s; Dropping record (scanKey: %s)"
                    .formatted(scannerResult.getStatus(), scanKey));
            return;
        }

        final var persistentVulns = new ArrayList<Vulnerability>();
        for (final org.hyades.proto.vuln.v1.Vulnerability hyadesVuln : scannerResult.getVulnerabilitiesList()) {
            final Vulnerability vuln;
            try {
                vuln = ModelConverter.convert(hyadesVuln);
            } catch (RuntimeException e) {
                LOGGER.error("""
                        Failed to convert vulnerability %s/%s (reported by %s for component %s) to internal model (scanKey: %s)"""
                        .formatted(hyadesVuln.getId(), hyadesVuln.getSource(), scannerResult.getScanner(), component.getUuid(), scanKey), e);
                continue;
            }

            try {
                // It is possible that the same vulnerability is reported for multiple components in parallel,
                // causing unique constraint violations when attempting to insert into the VULNERABILITY table.
                // In such cases, we can get away with simply retrying to SELECT or INSERT again.
                persistentVulns.add(qm.runInRetryableTransaction(
                        () -> syncVulnerability(qm, vuln, scannerResult.getScanner()),
                        PersistenceUtil::isUniqueConstraintViolation
                ));
            } catch (RuntimeException e) {
                // Use a broad catch here, so we can still try to process other
                // vulnerabilities, even though processing one of them failed.

                LOGGER.warn("Failed to synchronize vulnerability %s/%s (reported by %s for component %s; scanKey: %s)"
                        .formatted(vuln.getSource(), vuln.getVulnId(), scannerResult.getScanner(), component.getUuid(), scanKey));
            }
        }

        final Set<Vulnerability> newVulnerabilities = qm.runInTransaction(() -> {
            final var newVulns = new HashSet<Vulnerability>();
            for (final Vulnerability vuln : persistentVulns) {
                if (!qm.contains(vuln, component)) {
                    component.addVulnerability(vuln);
                    qm.getPersistenceManager().makePersistent(new FindingAttribution(component, vuln, getAnalyzerIdentity(scannerResult.getScanner()), null, null));
                    newVulns.add(vuln);
                }
            }
            return newVulns;
        });

        if (!newVulnerabilities.isEmpty()) {
            final Component detachedComponent = qm.getPersistenceManager().detachCopy(component);
            final Collection<Vulnerability> detachedVulns = qm.getPersistenceManager().detachCopyAll(newVulnerabilities);
            for (final Vulnerability detachedVuln : detachedVulns) {
                dispatchNotificationsWithSubject(
                        NotificationScope.PORTFOLIO,
                        NotificationGroup.NEW_VULNERABILITY,
                        NotificationUtil.generateNotificationTitle(NotificationConstants.Title.NEW_VULNERABILITY, detachedComponent.getProject()),
                        "",
                        NotificationLevel.INFORMATIONAL,
                        new NewVulnerabilityIdentified(detachedVuln, detachedComponent, Set.of(), VulnerabilityAnalysisLevel.BOM_UPLOAD_ANALYSIS));
            }
        }
    }

    /**
     * Synchronize a given {@link Vulnerability} as reported by a given {@link Scanner} with the datastore.
     * <p>
     * This method differs from {@link QueryManager#synchronizeVulnerability(Vulnerability, boolean)} in that it expects
     * an active {@link javax.jdo.Transaction}, and only calls setters of existing vulnerabilities when the respective
     * value actually changed, saving network round-trips.
     *
     * @param qm      The {@link QueryManager} to use
     * @param vuln    The {@link Vulnerability} to synchronize
     * @param scanner THe {@link Scanner} that reported the vulnerability
     * @return The synchronized {@link Vulnerability}
     * @throws IllegalStateException  When no {@link javax.jdo.Transaction} is active
     * @throws NoSuchElementException When the reported vulnerability is internal, but does not exist in the datastore
     */
    private Vulnerability syncVulnerability(final QueryManager qm, final Vulnerability vuln, final Scanner scanner) {
        if (!qm.getPersistenceManager().currentTransaction().isActive()) {
            throw new IllegalStateException("A transaction must be active in order to synchronize vulnerabilities");
        }

        final Query<Vulnerability> query = qm.getPersistenceManager().newQuery(Vulnerability.class);
        query.setFilter("vulnId == :vulnId && source == :source");
        query.setParameters(vuln.getVulnId(), vuln.getSource());
        final Vulnerability existingVuln = query.executeUnique();
        if (existingVuln == null) {
            if (Vulnerability.Source.INTERNAL.name().equals(vuln.getSource())) {
                throw new NoSuchElementException("An internal vulnerability with ID %s does not exist".formatted(vuln.getVulnId()));
            }

            return qm.getPersistenceManager().makePersistent(vuln);
        }

        // The vulnerability already exists, but we want to avoid scanners overriding mirrored vulnerabilities
        // from other sources like the NVD or GitHub. We allow them to modify existing vulnerabilities if they
        // themselves are the authoritative source, or the ACTUAL authoritative source is disabled.
        if (isAuthoritativeSource(existingVuln, scanner) || !isAuthoritativeSourceEnabled(qm, existingVuln)) {
            var updated = false;

            // TODO: Consider using something like javaers to get a rich diff of WHAT changed; https://github.com/javers/javers
            updated |= setIfChanged(existingVuln, vuln, Vulnerability::getTitle, existingVuln::setTitle);
            updated |= setIfChanged(existingVuln, vuln, Vulnerability::getSubTitle, existingVuln::setSubTitle);
            updated |= setIfChanged(existingVuln, vuln, Vulnerability::getDescription, existingVuln::setDescription);
            updated |= setIfChanged(existingVuln, vuln, Vulnerability::getDetail, existingVuln::setDetail);
            updated |= setIfChanged(existingVuln, vuln, Vulnerability::getRecommendation, existingVuln::setRecommendation);
            updated |= setIfChanged(existingVuln, vuln, Vulnerability::getReferences, existingVuln::setReferences);
            updated |= setIfChanged(existingVuln, vuln, Vulnerability::getCredits, existingVuln::setCredits);
            updated |= setIfChanged(existingVuln, vuln, Vulnerability::getCreated, existingVuln::setCreated);
            updated |= setIfChanged(existingVuln, vuln, Vulnerability::getPublished, existingVuln::setPublished);
            updated |= setIfChanged(existingVuln, vuln, Vulnerability::getUpdated, existingVuln::setUpdated);
            updated |= setIfChanged(existingVuln, vuln, Vulnerability::getCwes, existingVuln::setCwes);
            updated |= setIfChanged(existingVuln, vuln, Vulnerability::getCvssV2BaseScore, existingVuln::setCvssV2BaseScore);
            updated |= setIfChanged(existingVuln, vuln, Vulnerability::getCvssV2ImpactSubScore, existingVuln::setCvssV2ImpactSubScore);
            updated |= setIfChanged(existingVuln, vuln, Vulnerability::getCvssV2ExploitabilitySubScore, existingVuln::setCvssV2ExploitabilitySubScore);
            updated |= setIfChanged(existingVuln, vuln, Vulnerability::getCvssV2Vector, existingVuln::setCvssV2Vector);
            updated |= setIfChanged(existingVuln, vuln, Vulnerability::getCvssV3BaseScore, existingVuln::setCvssV3BaseScore);
            updated |= setIfChanged(existingVuln, vuln, Vulnerability::getCvssV3ImpactSubScore, existingVuln::setCvssV3ImpactSubScore);
            updated |= setIfChanged(existingVuln, vuln, Vulnerability::getCvssV3ExploitabilitySubScore, existingVuln::setCvssV2ExploitabilitySubScore);
            updated |= setIfChanged(existingVuln, vuln, Vulnerability::getCvssV3Vector, existingVuln::setCvssV3Vector);
            updated |= setIfChanged(existingVuln, vuln, Vulnerability::getOwaspRRLikelihoodScore, existingVuln::setOwaspRRLikelihoodScore);
            updated |= setIfChanged(existingVuln, vuln, Vulnerability::getOwaspRRTechnicalImpactScore, existingVuln::setOwaspRRTechnicalImpactScore);
            updated |= setIfChanged(existingVuln, vuln, Vulnerability::getOwaspRRBusinessImpactScore, existingVuln::setOwaspRRBusinessImpactScore);
            updated |= setIfChanged(existingVuln, vuln, Vulnerability::getOwaspRRVector, existingVuln::setOwaspRRVector);
            updated |= setIfChanged(existingVuln, vuln, Vulnerability::getSeverity, existingVuln::setSeverity);
            updated |= setIfChanged(existingVuln, vuln, Vulnerability::getVulnerableVersions, existingVuln::setVulnerableVersions);
            updated |= setIfChanged(existingVuln, vuln, Vulnerability::getPatchedVersions, existingVuln::setPatchedVersions);
            updated |= setIfChanged(existingVuln, vuln, Vulnerability::getEpssScore, existingVuln::setEpssScore);
            updated |= setIfChanged(existingVuln, vuln, Vulnerability::getEpssPercentile, existingVuln::setEpssPercentile);

            if (updated) {
                // TODO: Reduce to DEBUG; It's set to WARN for testing
                LOGGER.warn("Updated vulnerability %s/%s from scanner %s".formatted(vuln.getSource(), vuln.getVulnId(), scanner));
            }
        }

        return existingVuln;
    }

    private <T> boolean setIfChanged(final Vulnerability existingVuln, final Vulnerability vuln,
                                     final Function<Vulnerability, T> getter, final Consumer<T> setter) {
        final T existingValue = getter.apply(existingVuln);
        final T newValue = getter.apply(vuln);
        if (newValue != null && !Objects.equals(existingValue, newValue)) {
            setter.accept(newValue);
            return true;
        }
        return false;
    }

    private AnalyzerIdentity getAnalyzerIdentity(final Scanner scanner) {
        return switch (scanner) {
            case SCANNER_INTERNAL -> AnalyzerIdentity.INTERNAL_ANALYZER;
            case SCANNER_OSSINDEX -> AnalyzerIdentity.OSSINDEX_ANALYZER;
            case SCANNER_SNYK -> AnalyzerIdentity.SNYK_ANALYZER;
            default -> AnalyzerIdentity.NONE;
        };
    }

    private VulnerabilityAnalysisLevel determineAnalysisLevel(final FixedKeyRecord<?, ?> record) {
        final Header analysisLevelHeader = record.headers().lastHeader(KafkaEventHeaders.VULN_ANALYSIS_LEVEL);
        if (analysisLevelHeader != null && analysisLevelHeader.value() != null) {
            final var analysisTypeHeaderValue = new String(analysisLevelHeader.value(), StandardCharsets.UTF_8);
            try {
                return VulnerabilityAnalysisLevel.valueOf(analysisTypeHeaderValue);
            } catch (IllegalArgumentException e) {
                LOGGER.warn("The reported analysis type %s is invalid, assuming %s"
                        .formatted(analysisTypeHeaderValue, VulnerabilityAnalysisLevel.PERIODIC_ANALYSIS));
            }
        }

        return VulnerabilityAnalysisLevel.PERIODIC_ANALYSIS;
    }

    private boolean isAuthoritativeSource(final Vulnerability vuln, final Scanner scanner) {
        return switch (scanner) {
            case SCANNER_OSSINDEX -> Vulnerability.Source.OSSINDEX.name().equals(vuln.getSource());
            case SCANNER_SNYK -> Vulnerability.Source.SNYK.name().equals(vuln.getSource());
            default -> false;
        };
    }

    private boolean isAuthoritativeSourceEnabled(final QueryManager qm, final Vulnerability vuln) {
        final ConfigPropertyConstants authoritativeSourceToggle = switch (vuln.getSource()) {
            case "NVD" -> ConfigPropertyConstants.VULNERABILITY_SOURCE_NVD_ENABLED;
            case "GITHUB" -> ConfigPropertyConstants.VULNERABILITY_SOURCE_GITHUB_ADVISORIES_ENABLED;
            default -> null;
        };
        if (authoritativeSourceToggle == null) {
            return false;
        }

        final ConfigProperty configProperty = qm.getConfigProperty(
                authoritativeSourceToggle.getGroupName(),
                authoritativeSourceToggle.getPropertyName()
        );

        return configProperty != null && "true".equals(configProperty.getPropertyValue());
    }

}
