package org.dependencytrack.event.kafka.processor;

import alpine.common.logging.Logger;
import org.apache.kafka.common.header.Header;
import org.apache.kafka.streams.processor.api.Processor;
import org.apache.kafka.streams.processor.api.Record;
import org.dependencytrack.event.kafka.dto.AnalyzerCompletionStatus;
import org.dependencytrack.event.kafka.dto.AnalyzerConfig;
import org.dependencytrack.event.kafka.dto.VulnerabilityResult;
import org.dependencytrack.model.Component;
import org.dependencytrack.model.Vulnerability;
import org.dependencytrack.model.VulnerabilityAnalysisLevel;
import org.dependencytrack.persistence.QueryManager;
import org.dependencytrack.tasks.scanners.AnalyzerIdentity;
import org.dependencytrack.util.AnalyzerCompletionTracker;
import org.dependencytrack.util.NotificationUtil;

import java.nio.charset.StandardCharsets;
import java.util.Date;
import java.util.UUID;

public class VulnerabilityResultProcessor implements Processor<UUID, VulnerabilityResult, Void, Void> {

    private static final Logger LOGGER = Logger.getLogger(VulnerabilityResultProcessor.class);
    @Override
    public void process(final Record<UUID, VulnerabilityResult> record) {
        final UUID componentUuid = record.key();
        final VulnerabilityResult result = record.value();

        // TODO: Make the POC app support the level header
        final VulnerabilityAnalysisLevel level;
        final Header levelHeader = record.headers().lastHeader("level");
        if (levelHeader != null && levelHeader.value() != null) {
            level = VulnerabilityAnalysisLevel.valueOf(new String(levelHeader.value(), StandardCharsets.UTF_8));
        } else {
            level = VulnerabilityAnalysisLevel.BOM_UPLOAD_ANALYSIS;
        }

        try (final var qm = new QueryManager()) {
            final Component component = qm.getObjectByUuid(Component.class, componentUuid);
            if (component == null) {
                LOGGER.warn("Component " + componentUuid + " does not exist");
                return;
            }

            LOGGER.info("Received vulnerability analysis result");
            LOGGER.info(" - Component: " + component);
            try {
                AnalyzerConfig analyzerConfig = AnalyzerCompletionTracker.analyzerConfigMap.get(componentUuid);
                if (record.value().vulnerabilities() != null) {
                    for (Vulnerability vuln: record.value().vulnerabilities()) {
                        LOGGER.info(" - Vulnerability: " + vuln.getVulnId() + " (" + vuln.getSource() + ")");

                        // TODO: Will need to do some validation of the vulnerability data, and more sophisticated synchronization
                        // TODO: Should the analysis result have the SOURCE-VULNID combination as key? Would prevent race conditions in the check below.
                        Vulnerability vulnerability = qm.getVulnerabilityByVulnId(vuln.getSource(), vuln.getVulnId());
                        if (vulnerability == null) {
                            vulnerability = qm.createVulnerability(vuln, false);
                        }
                        //NotificationUtil.analyzeNotificationCriteria(qm, vulnerability, component, level);
                        qm.addVulnerability(vulnerability, component, result.identity());
                    }
                    AnalyzerCompletionStatus completionStatus = new AnalyzerCompletionStatus();
                    if(AnalyzerCompletionTracker.completionTrackMap.containsKey(componentUuid))
                        completionStatus = AnalyzerCompletionTracker.completionTrackMap.get(componentUuid);
                    else
                        AnalyzerCompletionTracker.completionTrackMap.put(componentUuid, completionStatus);
                    switch (record.value().identity()){
                        case INTERNAL_ANALYZER -> {
                            if(component.getCpe() != null && record.value().isCPE())
                                completionStatus.setInternalAnalyzerCompletedForCpe(true);
                            else
                                completionStatus.setInternalCompleted(true);
                        }
                        case OSSINDEX_ANALYZER -> completionStatus.setOSSCompleted(true);
                        case SNYK_ANALYZER -> completionStatus.setSnykCompleted(true);
                    }
                    if(((analyzerConfig.internalAnalyzerEnabled() && completionStatus.isInternalCompleted() )|| !analyzerConfig.internalAnalyzerEnabled())
                            && ((analyzerConfig.OSSEnabled()&& completionStatus.isOSSCompleted()) || !analyzerConfig.OSSEnabled())
                            && ((analyzerConfig.SnykEnabled()&& completionStatus.isSnykCompleted()) || !analyzerConfig.SnykEnabled())
                            &&  ((component.getCpe() != null && completionStatus.isInternalAnalyzerCompletedForCpe()) || component.getCpe() == null )){
                        System.out.println("completed");
                    }
                } else {
                    LOGGER.info(" - No Vulnerability");
                }
            } finally {
                // Ensure that the last vulnerability analysis timestamp is always updated.
                // Alternatively, implement a retry mechanism.
               // qm.runInTransaction(() -> component.setLastVulnerabilityAnalysis(new Date()));
            }
        }
    }
}
