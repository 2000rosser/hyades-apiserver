package org.dependencytrack.event.kafka.processor;

import alpine.common.logging.Logger;
import org.apache.kafka.common.header.Header;
import org.apache.kafka.streams.processor.api.Processor;
import org.apache.kafka.streams.processor.api.Record;
import org.dependencytrack.event.kafka.dto.VulnerabilityResult;
import org.dependencytrack.model.Component;
import org.dependencytrack.model.Vulnerability;
import org.dependencytrack.model.VulnerabilityAnalysisLevel;
import org.dependencytrack.persistence.QueryManager;
import org.dependencytrack.util.NotificationUtil;

import java.nio.charset.StandardCharsets;
import java.util.Date;
import java.util.UUID;

public class VulnerabilityResultProcessor implements Processor<UUID, VulnerabilityResult, Void, Void> {

    private static final Logger LOGGER = Logger.getLogger(VulnerabilityResultProcessor.class);

    @Override
    public void process(final Record<UUID, VulnerabilityResult> record) {
        final UUID componentUuid = record.key();
        final VulnerabilityResult result = record.value();

        // TODO: Make the POC app support the level header
        final VulnerabilityAnalysisLevel level;
        final Header levelHeader = record.headers().lastHeader("level");
        if (levelHeader != null && levelHeader.value() != null) {
            level = VulnerabilityAnalysisLevel.valueOf(new String(levelHeader.value(), StandardCharsets.UTF_8));
        } else {
            level = VulnerabilityAnalysisLevel.BOM_UPLOAD_ANALYSIS;
        }

        try (final var qm = new QueryManager()) {
            final Component component = qm.getObjectByUuid(Component.class, componentUuid);
            if (component == null) {
                LOGGER.warn("Component " + componentUuid + " does not exist");
                return;
            }

            LOGGER.info("Received vulnerability analysis result");
            LOGGER.info(" - Component: " + component);
            try {
                if (record.value().vulnerability() != null) {
                    LOGGER.info(" - Vulnerability: " + result.vulnerability().getVulnId() + " (" + result.vulnerability().getSource() + ")");

                    // TODO: Will need to do some validation of the vulnerability data, and more sophisticated synchronization
                    // TODO: Should the analysis result have the SOURCE-VULNID combination as key? Would prevent race conditions in the check below.
                    Vulnerability vulnerability = qm.getVulnerabilityByVulnId(result.vulnerability().getSource(), result.vulnerability().getVulnId());
                    if (vulnerability == null) {
                        vulnerability = qm.createVulnerability(result.vulnerability(), false);
                    }
                    NotificationUtil.analyzeNotificationCriteria(qm, vulnerability, component, level);
                    qm.addVulnerability(vulnerability, component, result.identity());
                } else {
                    LOGGER.info(" - No Vulnerability");
                }
            } finally {
                // Ensure that the last vulnerability analysis timestamp is always updated.
                // Alternatively, implement a retry mechanism.
                qm.runInTransaction(() -> component.setLastVulnerabilityAnalysis(new Date()));
            }
        }
    }

}
